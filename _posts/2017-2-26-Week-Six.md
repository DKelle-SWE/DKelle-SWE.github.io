---
layout: post
title: Week Six 
---

This week in Software Engineering, we have been preparing for our test. We finished the last lecture by touching on Decorators, and how they are useful. At the beginning of the lecture, I didn't really see the point, but after the lecture I understood what makes them helpful. A Decorator is almost just a function wrapper - it takes in a function as a parameter, and returns a callable function that does almost the same thing. It essentially allows you to add some arbitrary code to any function without actually altering the source of the initial function. What I can see being very useful is a time_function decorator - something that takes in a function, starts a timer, runs the function, and reports how long the function took. It would look something like this:

def time_function(func):
  def f():
    start = time.time()
    func()
    print(time.time()-start)
  return f
  
Now, if we have some function, g, and we want to see how long it will take to run, we must simply do the following:

timed_g = time_function(g)
timed_g()

Now this will do anything g() would do, plus output the time it took to run.


In the upcoming week of Software Engineering, we will be taking our first exam. Fortunately, Decorators will not be covered on the exam. However there will be plenty of confusing enough topics. Generators still confuse me, somewhat.
